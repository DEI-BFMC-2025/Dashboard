<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard</title>
    <style>
        .container {
            display: flex;
            gap: 20px;
        }
        .metrics {
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            width: 300px;
        }
        .metrics h3 {
            margin-top: 0;
        }
        .video-stream {
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>Dashboard</h1>
    <div class="container">
        <div class="metrics">
            <h2>Metrics</h2>
            <div id="metrics">
                <p><strong>CHECKPOINT:</strong> <span id="checkpoint">-</span></p>
                <p><strong>STATE:</strong> <span id="state">-</span></p>
                <p><strong>PREV EVENT:</strong> <span id="prev-event">-</span></p>
                <p><strong>NEXT EVENT:</strong> <span id="next-event">-</span></p>
                <p><strong>ROUTINES:</strong></p>
                <ul id="routines"></ul>
                <p><strong>CONDITIONS:</strong></p>
                <ul id="conditions"></ul>
            </div>
        </div>
        <div>
            <h2>Camera Feed</h2>
            <img class="video-stream" id="video-stream" src="/video_feed" width="320" height="240" />
        </div>
    </div>

    <h2>Run SSH Command</h2>
    <button onclick="runSSH()">Run ls /home/pi/Desktop</button>
    <pre id="output"></pre>

    <script>
        // Update metrics every second
        function updateMetrics() {
            fetch('/metrics')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('checkpoint').textContent = data.CHECKPOINT || '-';
                    document.getElementById('state').textContent = data.STATE || '-';
                    document.getElementById('prev-event').textContent = data.PREV_EVENT || '-';
                    document.getElementById('next-event').textContent = data.UPCOMING_EVENT || '-';

                    // Update routines
                    const routinesList = document.getElementById('routines');
                    routinesList.innerHTML = '';
                    if (data.ROUTINES) {
                        data.ROUTINES.forEach(routine => {
                            const li = document.createElement('li');
                            li.textContent = routine;
                            routinesList.appendChild(li);
                        });
                    }

                    // Update conditions
                    const conditionsList = document.getElementById('conditions');
                    conditionsList.innerHTML = '';
                    if (data.CONDITIONS) {
                        for (const [key, value] of Object.entries(data.CONDITIONS)) {
                            const li = document.createElement('li');
                            li.textContent = `${key}: ${value}`;
                            conditionsList.appendChild(li);
                        }
                    }
                })
                .catch(error => console.error('Error fetching metrics:', error));
        }

        // Update metrics every second
        setInterval(updateMetrics, 1000);

        // SSH command
        function runSSH() {
            fetch('/run-ssh', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    document.getElementById('output').innerText = data.output || data.error;
                })
                .catch(error => {
                    document.getElementById('output').innerText = "Error: " + error;
                });
        }
    </script>
</body>
</html>